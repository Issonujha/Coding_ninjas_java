/*
	
	Following is the structure used to represent the Binary Tree Node

	class BinaryTreeNode<T> {
		T data;
		BinaryTreeNode<T> left;
		BinaryTreeNode<T> right;

		public BinaryTreeNode(T data) {
			this.data = data;
			this.left = null;
			this.right = null;
		}
	}

 */

public class Solution {
	public static int maximum(BinaryTreeNode<Integer> root) {
        if(root==null) {
            return Integer.MIN_VALUE;
        }
        return Math.max(root.data, Math.max(maximum(root.left), maximum(root.right)));
    }
    public static int minimum(BinaryTreeNode<Integer> root) {
        if(root==null) {
            return Integer.MAX_VALUE;
        }
        return Math.min(root.data, Math.min(minimum(root.left), minimum(root.right)));
    }
	public static boolean isBST(BinaryTreeNode<Integer> root) {

		/* Your class should be named Solution
		 * Don't write main().
		 * Don't read input, it is passed as function argument.
		 * Return output and don't print it.
	 	 * Taking input and printing output is handled automatically.
        */
        if(root==null) {
            return true;
        }
        int max = maximum(root.left);
        int min = minimum(root.right);
        if(max>root.data) {
            return false;
        }
        if(min<root.data) {
            return false;
        }
        boolean left = isBST(root.left);
        boolean right = isBST(root.right);
        if(left && right) {
            return true;
        }
        else {
            return false;
        }
	}
}
//     public static boolean isBST(BinaryTreeNode<Integer> root) {
//     	Pair<Boolean, Pair<Integer, Integer>> output = isBST2(root);
//         return output.first;
//     }
//     public static Pair<Boolean, Pair<Integer, Integer>> isBST2(BinaryTreeNode<Integer> root) {
// 		if(root==null) {
// 			Pair<Boolean, Pair<Integer, Integer>> output = new Pair<Boolean, Pair<Integer, Integer>>();
// 			output.first = true;
// 			output.second = new Pair<>();
// 			output.second.first = Integer.MAX_VALUE;
// 			output.second.second = Integer.MIN_VALUE;
// 			return output;
// 		}
// 		Pair<Boolean, Pair<Integer, Integer>> left = isBST2(root.left);
// 		Pair<Boolean, Pair<Integer, Integer>> right = isBST2(root.right);
// 		int min = Math.min(root.data, Math.min(left.second.first, right.second.first));
// 		int max = Math.max(root.data, Math.max(left.second.second, right.second.second));
// 		boolean isBST = (root.data<right.second.first && root.data>left.second.second) && left.first && right.first;
// 		Pair<Boolean, Pair<Integer, Integer>> output = new Pair<Boolean, Pair<Integer, Integer>>();
// 		output.first = isBST;
// 		output.second = new Pair<>();
// 		output.second.first = min;
// 		output.second.second = max;
// 		return output;
// 	}

// }
// class Pair<T, V> {
//     T first;
//     V second;
// }